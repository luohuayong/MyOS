# 栈帧（Stack Frame）概念与最佳实践

栈帧（Stack Frame）是在函数调用期间，在程序栈（Stack）上为该函数分配的**私有内存工作空间**。它是实现结构化编程、参数传递、局部变量管理和现场保存的核心机制。

## 一、核心概念与组成部分

每次执行 `CALL` 指令调用一个函数时，都会在栈上创建一个新的栈帧。该栈帧的边界和内容由 $\text{SP}$ 和 $\text{BP}$ 两个寄存器控制。

### 1. 关键寄存器

| 寄存器                                   | 全称       | 作用                                                                            |
| :--------------------------------------- | :--------- | :------------------------------------------------------------------------------ |
| **$\text{SP}$** ($\text{Stack Pointer}$) | 栈指针     | 始终指向**栈顶**，地址会随着数据 $\text{PUSH}/\text{POP}$ 而变化。              |
| **$\text{BP}$** ($\text{Base Pointer}$)  | 栈基址指针 | 指向栈帧内的**固定参考点**（通常是保存旧 $\text{BP}$ 的位置），用于稳定的寻址。 |

### 2. 栈帧结构

典型的 8086 栈帧从内存地址高到低（即栈底到栈顶）依次包含以下信息：

1.  **参数 (Arguments):** 调用者传入的参数值。
2.  **返回地址 (Return Address):** `CALL` 指令自动压入的地址，确保函数返回后程序能继续执行。
3.  **保存的旧 $\text{BP}$ (Old BP):** 调用者函数的基址指针，用于函数返回后恢复调用者的栈帧。
4.  **保存的寄存器 (Saved Registers):** 被调用函数为保护现场而 $\text{PUSH}$ 入栈的寄存器值。
5.  **局部变量 (Local Variables):** 函数内部定义和使用的临时变量空间。

---

## 二、栈帧的核心用途

栈帧机制解决了结构化程序设计中的三大问题：

### 1. 稳定的参数和局部变量访问

- **问题：** 栈指针 $\text{SP}$ 是动态变化的。如果在函数内部 $\text{PUSH}$ 或 $\text{POP}$ 数据，参数和局部变量的相对地址会改变。
- **解决方案：** 函数建立栈帧后，**$\text{BP}$ 保持不变**。
  - **访问参数：** 通过 **正偏移量** ($\text{BP} + N$) 访问参数。
  - **访问局部变量：** 通过 **负偏移量** ($\text{BP} - N$) 访问局部变量。

### 2. 现场（Context）保存与恢复

栈帧确保了函数调用的独立性，不干扰调用者的执行环境：

- **控制流现场：** 存储**返回地址**，通过 $\text{RET}$ 恢复程序执行的流程。
- **环境现场：** 存储**旧 $\text{BP}$** 和任何被函数修改的**非易失性寄存器**，在函数返回时恢复调用者的寄存器状态。

### 3. 支持递归（Recursion）

每次递归调用都会建立一个全新的栈帧，这个栈帧包含该次调用的所有局部变量和返回地址。这使得递归的每一次执行都是隔离的，从而能够正确地进行嵌套和最终返回。

---

## 三、8086 汇编下的栈帧最佳实践

为了确保代码的健壮性和兼容性，在 8086 汇编中编写函数时，应严格遵循以下惯例：

### 1. 函数的建立（Prologue，序言）

函数开始时必须建立栈帧并保存现场：

| 步骤                   | 指令                          | 目的                                                               |
| :--------------------- | :---------------------------- | :----------------------------------------------------------------- |
| **保存 $\text{BP}$**   | `PUSH BP`                     | 保存调用者的栈帧基址。                                             |
| **建立新 $\text{BP}$** | `MOV BP, SP`                  | 将当前 $\text{SP}$ 设为新 $\text{BP}$，作为本函数栈帧的基址。      |
| **保存寄存器**         | `PUSH DS / PUSH SI / PUSH DI` | 保存函数可能修改的、但调用者需要其原始值的寄存器（Callee Saves）。 |
| **分配局部变量**       | `SUB SP, N`                   | 如果需要局部变量，分配 $N$ 字节空间。                              |

### 2. 函数的拆除（Epilogue，尾声）

函数结束前必须精确地恢复现场：

| 步骤                 | 指令                       | 目的                                                                                                                          |
| :------------------- | :------------------------- | :---------------------------------------------------------------------------------------------------------------------------- |
| **恢复寄存器**       | `POP DI / POP SI / POP DS` | 恢复现场，顺序必须与 $\text{PUSH}$ 顺序相反。                                                                                 |
| **恢复 $\text{SP}$** | `POP BP`                   | **恢复 $\text{BP}$** 会自动将 $\text{SP}$ 恢复到 $\text{BP}$ 之前的位置，同时将旧的 $\text{BP}$ 弹出到 $\text{BP}$ 寄存器中。 |
| **返回**             | `RET` 或 `RET N`           | 弹出返回地址到 $\text{IP}$。 $\text{RET N}$ 额外清理栈上的参数。                                                              |

### 3. 参数传递约定

| 约定         | 负责方               | 常用指令                                  |
| :----------- | :------------------- | :---------------------------------------- |
| **参数传递** | 调用者（Caller）     | `PUSH [ParamN]` ... $\to$ `PUSH [Param1]` |
| **栈清理**   | 约定调用方（Caller） | `ADD SP, N` (函数返回后)                  |
| **结果返回** | 约定函数体（Callee） | 结果通常放置在 **$\text{AX}$** 寄存器中。 |

### 四、栈帧的使用示例 (8086 汇编)

下面的函数 ADD_NUMBERS 演示了如何通过栈帧访问两个参数（Num1, Num2），并使用局部变量 ($\text{LocalSum}$) 存储中间结果。

#### 1. 完整的汇编代码示例

```asm
; =========================================================
; 扁平模型 / .COM 风格 - 移除所有 MASM 伪指令
; 假定 CS=DS=ES=SS，程序从 0100h 开始加载
; =========================================================

ORG 0100H           ; .COM 程序的标准起始地址

start:
    ; 1. 初始化 DS/ES (在 .COM 中可选，但最好保证)
    MOV AX, CS      ; 将代码段地址加载到 AX
    MOV DS, AX      ; 设置数据段 (假设数据在代码后面)

    ; 2. CALLER (调用者) 准备参数 (计算 10 + 20)
    PUSH 20         ; PUSH Num2 (在 [BP+6] 处)
    PUSH 10         ; PUSH Num1 (在 [BP+4] 处)

    CALL ADD_NUMBERS

    ; 3. CALLER 清理栈上参数 (两个字，共 4 字节)
    ADD SP, 4

    ; 4. 结果在 AX 中，可以存储或使用
    MOV [RESULT_VAR_ADDR], AX ; 结果存储到后面定义的变量

    ; 5. 程序退出 (不使用 INT 21H / 20H，进入无限循环)
    JMP $

; --- 数据定义 ---
RESULT_VAR_ADDR DW 0 ; 结果变量地址
                   ; 注意：在扁平模型中，数据和代码地址是连续的

; =========================================================
; CALLEE (被调用函数): ADD_NUMBERS 标签
; =========================================================

ADD_NUMBERS:
    ; --- Prologue (建立栈帧) ---
    PUSH BP         ; 1. 保存旧 BP
    MOV BP, SP      ; 2. 建立新 BP

    ; 3. [可选] 保存寄存器
    PUSH BX

    ; 4. 分配局部变量空间（2字节）
    SUB SP, 2       ; SP = SP - 2 (在 [BP-2] 处创建 LocalSum)

    ; --- 函数体 (执行逻辑) ---

    ; 5. 访问参数：计算 Num1 + Num2
    MOV AX, [BP+4]  ; 获取 Num1 (参数 1)
    MOV BX, [BP+6]  ; 获取 Num2 (参数 2)
    ADD AX, BX

    ; 6. 存储到局部变量 LocalSum
    MOV [BP-2], AX  ; LocalSum = Num1 + Num2

    ; 7. 将结果加载到 AX (作为返回值)
    MOV AX, [BP-2]

    ; 8. 恢复寄存器
    POP BX

    ; --- Epilogue (拆除栈帧) ---

    ; 9. 恢复栈指针 (清理局部变量)
    MOV SP, BP      ; SP 恢复到 PUSH BP 之前的位置

    ; 10. 恢复旧 BP
    POP BP          ; 恢复调用者的栈帧基址

    ; 11. 返回控制流
    RET
```
