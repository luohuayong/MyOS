# 8086 段寄存器

段寄存器是 8086 分段内存模型的核心组件，用于将 16 位的逻辑地址映射到 20 位的物理地址，从而实现对 1MB 内存空间的寻址。

---

## 📌 **段寄存器有哪些？**

8086 有 **4 个 16 位段寄存器**，每个都有专门用途：

| 段寄存器 | 英文全称          | 主要用途                             | 默认搭配的偏移寄存器     |
| -------- | ----------------- | ------------------------------------ | ------------------------ |
| **CS**   | **Code Segment**  | 代码段，存放当前执行的指令           | IP (Instruction Pointer) |
| **DS**   | **Data Segment**  | 数据段，存放程序访问的多数数据       | BX、SI、DI、直接地址等   |
| **SS**   | **Stack Segment** | 堆栈段，存放栈空间                   | SP (Stack Pointer)、BP   |
| **ES**   | **Extra Segment** | 附加段，常用于字符串操作的目标数据区 | DI (用于字符串目标)      |

---

## 🧮 **物理地址计算公式**

这是段寄存器最核心的作用：

```
物理地址 = (段寄存器值 × 16) + 偏移地址
```

- **×16** 等价于左移 4 位（十六进制左移一位）。
- 偏移地址来自 IP、SP、BP、BX、SI、DI 或立即数。

**示例**：

```
CS = 0x1234
IP = 0x5678
物理地址 = 0x12340 + 0x5678 = 0x179B8
```

---

## 📍 **段寄存器的默认组合（隐式规则）**

CPU 在执行指令时，会根据操作类型自动选择段寄存器，除非显式用段超越前缀覆盖：

| 操作类型                           | 使用的偏移地址来源     | **默认段寄存器** | 可超越的段              |
| ---------------------------------- | ---------------------- | ---------------- | ----------------------- |
| 取指令                             | IP                     | **CS**           | 不可超越                |
| 堆栈操作（PUSH、POP、CALL）        | SP                     | **SS**           | 不可超越                |
| 使用 BP 作为基址寻址               | BP、BP+SI、BP+DI 等    | **SS**           | CS、DS、ES              |
| 字符串指令的目标操作（STOS、MOVS） | DI                     | **ES**           | 不可超越（目标固定 ES） |
| 其他数据访问（多数 MOV、ADD 等）   | BX、SI、DI、直接地址等 | **DS**           | CS、SS、ES              |

---

## 🔄 **段寄存器的加载**

不能直接用立即数给段寄存器赋值，必须通过通用寄存器或内存：

```assembly
MOV AX, 0x2000
MOV DS, AX        ; 正确：DS = 0x2000
MOV DS, 0x2000    ; 错误：不允许立即数到段寄存器

MOV DS, [BX]      ; 从内存加载到 DS（需通过通用寄存器中转？）
; 实际需要：
MOV AX, [BX]
MOV DS, AX
```

专门的段加载指令：

```assembly
LDS SI, [table]    ; 同时加载 DS 和 SI（远指针）
LES DI, [buffer]   ; 同时加载 ES 和 DI
```

---

## ⚠️ **重要特性和限制**

1. **段寄存器不可直接运算**  
   不能对 CS、DS、SS、ES 进行算术或逻辑运算（如 `ADD DS, AX` 非法）。

2. **堆栈段 SS 的特殊性**

   - SS:SP 必须指向有效的栈空间。
   - 修改 SS 和 SP 的指令应连续执行（中间不插入其他指令），以免中断发生时栈指针不一致。

3. **代码段 CS 的修改**  
   CS 不能通过 `MOV` 修改，只能通过 **远转移（JMP FAR）、远调用（CALL FAR）、远返回（RETF）** 或 **中断返回（IRET）** 改变。

4. **段的大小与范围**

   - 每个段最大 64KB（因为偏移地址是 16 位）。
   - 段起始地址总是 **16 字节对齐**（因为左移 4 位，低 4 位为 0）。

5. **段重叠与别名**  
   同一个物理地址可有多个逻辑地址表示（如 2000:0100 和 2100:0000 都指向 20100h）。

---

## 💡 **段超越前缀**

在指令前加段寄存器名和冒号，可强制使用指定段：

```assembly
MOV AX, ES:[BX]      ; 使用 ES 而非默认 DS
MOV DX, SS:[BP+4]    ; 明确使用 SS（其实默认就是SS，这里显式说明）
MOV AL, CS:[100h]    ; 读取代码段中的数据
```

机器码中，段超越前缀是一个额外字节（如 `26h` 代表 ES，`2Eh` 代表 CS，`36h` 代表 SS，`3Eh` 代表 DS）。

---

## 🧩 **为什么需要分段？**

1. **历史兼容**：8086 前代 8080 是 16 位地址（64KB），分段可在兼容基础上扩展。
2. **扩大寻址**：用 16 位寄存器实现 20 位地址空间（1MB）。
3. **逻辑隔离**：代码、数据、堆栈分开管理，提高程序结构性。
4. **重定位支持**：程序可加载到不同物理地址，只需调整段寄存器。

---

## 📚 **总结**

- 段寄存器是 **CS、DS、SS、ES**。
- 它们将 **16 位逻辑地址扩展为 20 位物理地址**。
- 有严格的**默认使用规则**，可用**段超越前缀**覆盖。
- 是理解 8086/8088 及后续 x86 实模式编程的基础。

正是因为分段机制，8086 能在 16 位架构上实现 1MB 内存寻址，这也成为后来 x86 系列兼容性负担与保护模式发展的起点。
